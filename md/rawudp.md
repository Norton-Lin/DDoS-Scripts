# rawudp.c
这个代码实现了**UDP洪水攻击**，感觉有两点比较不一样，这个md里介绍一下

## 特点一：随机数
这段代码里使用随机数主要是为了**重新生成随机的源端口号和源IP地址，以此来绕过一些简单的防护措施。**

具体的实现函数是**uint32_t rand_cmwc(void)**函数，该函数使用了线性同余的方法

### 线性同余
[参考资料](https://blog.csdn.net/virtualxiaoman/article/details/131985603)

$X_{n+1}$ = (a*$X_n$ + c) mod m

该LGC(Linear Congruential Generator, LCG)算法通过特定的公式递归地生成一系列数值，这些数值在一定范围内均匀分布，可以作为随机数使用。

相关代码：

    uint64_t t, a = 18782LL;
定义了一个64位的无符号整数t作为中间变量，以及一个常数a，其值为18782，这是LCG算法中的乘数。

    static uint32_t i = 4095;
定义了一个静态的32位无符号整数i作为序列的当前位置，初始值为4095。静态变量的值在函数调用结束后不会改变，所以每次生成随机数时，i的值会持续更新。

    uint32_t x, r = 0xfffffffe;
定义了两个32位无符号整数x和r。r被初始化为0xfffffffe，这是一个常数，用于后面的计算。

    i = (i + 1) & 4095;
更新i的值，使其循环在0到4095之间。这是通过将i加1然后与4095进行按位与操作来实现的，这样可以保证i在达到4096时回到0，形成一个循环。

    t = a * Q[i] + c;
计算LCG的下一个数值。这里Q[i]是前一个随机数，c是增量（在代码的其他地方定义）。

    c = (t >> 32);
将t右移32位，将高位部分赋值给c。这是因为t是一个64位的数，而我们只需要32位的随机数，所以通过右移来分离出高位和低位。

    x = t + c;
将t和c相加，得到一个32位的结果x。


    if (x < c) {
        x++;
        c++;
    }
这个条件判断是为了处理当x加上c后发生溢出的情况。如果x小于c，说明发生了溢出，此时x需要加1，c也需要加1。


    return (Q[i] = r - x);
最后，将r减去x，得到最终的随机数，并将其存储在Q[i]中。这样，每次调用rand_cmwc函数时，都会生成一个新的随机数，并更新Q[i]的值。

## 特点二：速率控制
具体可以看代码注释**void *flood(void *par1)**函数
